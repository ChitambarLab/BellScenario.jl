var documenterSearchIndex = {"docs":
[{"location":"BellScenario/combinatorics/","page":"Combinatorics","title":"Combinatorics","text":"CurrentModule = BellScenario","category":"page"},{"location":"BellScenario/combinatorics/#Combinatorics-Utilities","page":"Combinatorics","title":"Combinatorics Utilities","text":"","category":"section"},{"location":"BellScenario/combinatorics/#Set-Partitions","page":"Combinatorics","title":"Set Partitions","text":"","category":"section"},{"location":"BellScenario/combinatorics/","page":"Combinatorics","title":"Combinatorics","text":"stirling2\nstirling2_partitions\nstirling2_matrices","category":"page"},{"location":"BellScenario/combinatorics/#BellScenario.stirling2","page":"Combinatorics","title":"BellScenario.stirling2","text":"stirling2( n :: Int64, k :: Int64  ) :: Int64\n\nCounts the number of ways to partition n items into k unlabelled groups. This quantity is known as Stirling's number of the 2nd kind:\n\nleftn atop k right = frac1ksum_i=0^k (-1)^ibinomki(k-i)^n\n\nThrows a DomainError if inputs do not satisfy n ≥ k ≥ 1.\n\n\n\n\n\n","category":"function"},{"location":"BellScenario/combinatorics/#BellScenario.stirling2_partitions","page":"Combinatorics","title":"BellScenario.stirling2_partitions","text":"stirling2_partitions( n :: Int64, k :: Int64 ) :: Vector{Vector{Vector{Int64}}}\n\nEnumerates the unique partitions of n items into k unlabelled sets. Each partition is a vector containing a  set of k vectors designating each group.\n\nE.g.\n\njulia> stirling2_partitions( 4, 2 )\n7-element Array{Array{Array{Int64,1},1},1}:\n [[1, 2, 3], [4]]\n [[3], [1, 2, 4]]\n [[1, 2], [3, 4]]\n [[1, 3], [2, 4]]\n [[2], [1, 3, 4]]\n [[2, 3], [1, 4]]\n [[1], [2, 3, 4]]\n\nThis recursive algorithm was inspired by this blog.\n\n\n\n\n\n","category":"function"},{"location":"BellScenario/combinatorics/#BellScenario.stirling2_matrices","page":"Combinatorics","title":"BellScenario.stirling2_matrices","text":"stirling2_matrices( n :: Int64, k :: Int64 ) :: Vector{Matrix{Bool}}\n\nGenerates the set of matrices with k rows and n columns where rows correspond to the groups and columns are the grouped elements. A non-zero element designates that the column id is grouped into the corresponding row.\n\nE.g.\n\njulia> stirling2_matrices( 4, 2 )\n7-element Array{Array{Bool,2},1}:\n [1 1 1 0; 0 0 0 1]\n [0 0 1 0; 1 1 0 1]\n [1 1 0 0; 0 0 1 1]\n [1 0 1 0; 0 1 0 1]\n [0 1 0 0; 1 0 1 1]\n [0 1 1 0; 1 0 0 1]\n [1 0 0 0; 0 1 1 1]\n\nA DomainError is thrown if n ≥ k ≥ 1 is not satisfied.\n\n\n\n\n\n","category":"function"},{"location":"BellScenario/combinatorics/#Matrix-Constructions","page":"Combinatorics","title":"Matrix Constructions","text":"","category":"section"},{"location":"BellScenario/combinatorics/","page":"Combinatorics","title":"Combinatorics","text":"permutation_matrices\nn_choose_k_matrices","category":"page"},{"location":"BellScenario/combinatorics/#BellScenario.permutation_matrices","page":"Combinatorics","title":"BellScenario.permutation_matrices","text":"permutation_matrices( dim :: Int64 ) :: Vector{Matrix{Bool}}\n\nGenerates the set of square permutation matrices of dimension dim.\n\nE.g.\n\njulia> permutation_matrices( 3 )\n6-element Array{Array{Bool,2},1}:\n [1 0 0; 0 1 0; 0 0 1]\n [1 0 0; 0 0 1; 0 1 0]\n [0 1 0; 1 0 0; 0 0 1]\n [0 0 1; 1 0 0; 0 1 0]\n [0 1 0; 0 0 1; 1 0 0]\n [0 0 1; 0 1 0; 1 0 0]\n\n\n\n\n\n","category":"function"},{"location":"BellScenario/combinatorics/#BellScenario.n_choose_k_matrices","page":"Combinatorics","title":"BellScenario.n_choose_k_matrices","text":"n_choose_k_matrices( n :: Int64, k :: Int64 ) :: Vector{Matrix{Bool}}\n\nGenerates a set of n by k matrices which represent all combinations of selecting k columns from n rows.  Each column, contains a single non-zero element and k rows contain a non-zero element.\n\nE.g.\n\njulia> n_choose_k_matrices( 4, 2 )\n6-element Array{Array{Bool,2},1}:\n [1 0; 0 1; 0 0; 0 0]\n [1 0; 0 0; 0 1; 0 0]\n [1 0; 0 0; 0 0; 0 1]\n [0 0; 1 0; 0 1; 0 0]\n [0 0; 1 0; 0 0; 0 1]\n [0 0; 0 0; 1 0; 0 1]\n\nA DomainError is thrown if n ≥ k ≥ 1 is not satisfied.\n\n\n\n\n\n","category":"function"},{"location":"BellScenario/combinatorics/#Alternative-Number-Bases","page":"Combinatorics","title":"Alternative Number Bases","text":"","category":"section"},{"location":"BellScenario/combinatorics/","page":"Combinatorics","title":"Combinatorics","text":"base_n_val","category":"page"},{"location":"BellScenario/combinatorics/#BellScenario.base_n_val","page":"Combinatorics","title":"BellScenario.base_n_val","text":"base_n_val(\n    num_array :: Vector{Int64},\n    base :: Int64;\n    big_endian=true :: Bool\n) :: Int64\n\nGiven an array representing a number in base-n returns the value of that number in base-10.\n\nInputs:\n\nnum_array - Vector containing semi-positive integers less than base.\nbase - The base-n number represented by num_array.\nbig_endian - true if most significant place is at index 1, else false.\n\n\n\n\n\n","category":"function"},{"location":"BellScenario/overview/#BellScenario.jl-Overview","page":"Overview","title":"BellScenario.jl - Overview","text":"","category":"section"},{"location":"BellScenario/overview/","page":"Overview","title":"Overview","text":"BellScenario","category":"page"},{"location":"BellScenario/overview/#BellScenario","page":"Overview","title":"BellScenario","text":"Types and constructors that represent Bell scenarios, their statistics, and their bounds.\n\nThe BellScenario.jl module is the base library for Bell scenario analysis.\n\nFeatures:\n\nScenario: abstract type describing Bell scenarios.\nAbstractStrategy: abstract type for Bell scenario statistics.\nAbstractGame: abstract type for Bell scenario bounds.\n\nA game theoretic framework is used to evaluate the performance of black-box systems. A cost function testing the black-box system is regarded as a game while the statistics generated by the black-box system are regarded as a strategy. A strategy is played against a game to achieve a score, hence, this framework provides a quantitative metric of the performance of a black-box system in regards to a particular task.\n\n\n\n\n\n","category":"module"},{"location":"BellScenario/overview/#Black-Box-Devices","page":"Overview","title":"Black-Box Devices","text":"","category":"section"},{"location":"BellScenario/overview/","page":"Overview","title":"Overview","text":"A black-box device describes a physical system with inputs and outputs that an observer can test, however, the observer has no knowledge of the physical system contained within the device.","category":"page"},{"location":"BellScenario/overview/","page":"Overview","title":"Overview","text":"(Image: Black-Box Device)","category":"page"},{"location":"BellScenario/overview/","page":"Overview","title":"Overview","text":"A black-box device accepts and input x and produces an output y. No assumptions are made about how y is computed from x. A black-box is characterized by its conditional probability distribution S(yx) which can be derived by collecting the input-output statistics of the black-box. The distribution S(yx) is a stochastic map taking input x to output y. In BellScenario.jl, stochastic maps are referred to as strategies and outlined in greater detail in the BellScenario.jl - Strategies section.","category":"page"},{"location":"BellScenario/overview/#Resources","page":"Overview","title":"Resources","text":"","category":"section"},{"location":"BellScenario/overview/","page":"Overview","title":"Overview","text":"The statistics achieved by Bell scenario depend on the resources available in the black-box system. In the context of Bell scenarios, resources describe the connection between black-boxes. Resources are typically limited and place restrictions on the black-box system.","category":"page"},{"location":"BellScenario/overview/#Communication-Resources:","page":"Overview","title":"Communication Resources:","text":"","category":"section"},{"location":"BellScenario/overview/","page":"Overview","title":"Overview","text":"Two (or more) black-boxes may coordinate using a limited amount of communication.","category":"page"},{"location":"BellScenario/overview/","page":"Overview","title":"Overview","text":"Classical Communication - A classical state is sent from one black-box to another.\nQuantum Communication - A quantum state is sent from one black-box to another.","category":"page"},{"location":"BellScenario/overview/","page":"Overview","title":"Overview","text":"Communication resources are used during a Bell test. Classical communication resources are measured in dits which describes the number of distinct messages that can be sent. Quantum communication resources are measured in qudits which describes the Hilbert space dimension of the quantum state used to communicate. Quantum communication can simulate classical communication by encoding the classical messages as an orthogonal basis on the qudit Hilbert space.","category":"page"},{"location":"BellScenario/overview/#Correlation-Resources:","page":"Overview","title":"Correlation Resources:","text":"","category":"section"},{"location":"BellScenario/overview/","page":"Overview","title":"Overview","text":"Two (or more) black-boxes may coordinate using a limited amount of correlation.","category":"page"},{"location":"BellScenario/overview/","page":"Overview","title":"Overview","text":"Shared Randomness - Two or more black-boxes share a random variable lambda     drawn from a sample space Lambda with probability  q(lambda).\nQuantum Entanglement  - Two or more black-boxes share a non-separable quantum     state.","category":"page"},{"location":"BellScenario/overview/","page":"Overview","title":"Overview","text":"Correlation resources may be distributed before any Bell tests are run.","category":"page"},{"location":"BellScenario/overview/#Diagrams","page":"Overview","title":"Diagrams","text":"","category":"section"},{"location":"BellScenario/overview/","page":"Overview","title":"Overview","text":"A Bell scenario is depicted by a Directed Acyclic Graph (DAG) which shows the causal flow of information through the black-box system. For example, the following figure shows a bipartite signaling scenario.","category":"page"},{"location":"BellScenario/overview/","page":"Overview","title":"Overview","text":"(Image: Bipartite Signaling Scenario Diagram)","category":"page"},{"location":"BellScenario/overview/","page":"Overview","title":"Overview","text":"In the diagram, the information flows from inputs x and y to outputs a and b. In general, a free origin of an arrow corresponds to an input of the Bell scenario while a free point of an arrow corresponds to an output of the Bell scenario. The blue rectangular nodes in the graph represent black-box devices, e.g. A_lambda(ax) and B_lambda(bmy). When communication is present between two black-boxes, it is depicted by a solid arrow originating at one node and terminating at another. The red circular nodes in the graph, e.g. Lambda, represent correlation resources. When a correlation resource is shared between two black-boxes, it is depicted by a red dotted arrow flowing from the correlation resource node to the each of the black-box nodes.","category":"page"},{"location":"LocalPolytope/utils/","page":"Utilities","title":"Utilities","text":"CurrentModule = LocalPolytope","category":"page"},{"location":"LocalPolytope/utils/#Utilities-for-Facets-and-Vertices","page":"Utilities","title":"Utilities for Facets and Vertices","text":"","category":"section"},{"location":"LocalPolytope/utils/","page":"Utilities","title":"Utilities","text":"dimension","category":"page"},{"location":"LocalPolytope/utils/#BellScenario.LocalPolytope.dimension","page":"Utilities","title":"BellScenario.LocalPolytope.dimension","text":"dimension( vertices :: Vector{Vector{Int64}} ) :: Int64\n\nFor the provided vertices (points), finds the dimension of the affine space spanned by the vertices. This method computes the dimension of a polytope, facet, or collection of points.\n\nThis also accepts matrices and DeterministicStrategy types as arguments:\n\ndimension( vertices :: Vector{Matrix{Int64}} ) :: Int64\n\ndimension( vertices :: Vector{DeterministicStrategy} ) :: Int64\n\n\n\n\n\n","category":"function"},{"location":"BellScenario/strategies/","page":"Strategies","title":"Strategies","text":"CurrentModule = BellScenario","category":"page"},{"location":"BellScenario/strategies/#BellScenario.jl-Strategies","page":"Strategies","title":"BellScenario.jl - Strategies","text":"","category":"section"},{"location":"BellScenario/strategies/","page":"Strategies","title":"Strategies","text":"AbstractStrategy\nStrategy\nstrategy_dims\nrandom_strategy","category":"page"},{"location":"BellScenario/strategies/#BellScenario.AbstractStrategy","page":"Strategies","title":"BellScenario.AbstractStrategy","text":"An AbstractStrategy is an abstract type parent to all strategy matrices. A black-box device is characterized by its conditional probabilities which can be organized into a strategy matrix or column-stochastic map S  mathcalX to mathcalY. The strategy matrix S is constructed as follows,\n\nS = sum_xy P(yx) yranglelangle x\n\nwhere the elements of a strategy matrix must be non-negative and normalized:\n\nP(yx) geq 0\nsum_y P(yx) = 1\n\nSince strategies are just stochastic matrices, the product of two strategies yields a new strategy, e.g. S_A*S_B = S_C.\n\n*(S1::AbstractStrategy, S2::AbstractStrategy) :: Strategy\n\nWhen multiplied together, two strategies may represent a new Scenario, hence, a the multiplication operator can also be passed a Scenario.\n\n*(S1::AbstractStrategy, S2::AbstractStrategy, scenario::Scenario) :: Strategy\n\n\n\n\n\n","category":"type"},{"location":"BellScenario/strategies/#BellScenario.Strategy","page":"Strategies","title":"BellScenario.Strategy","text":"Strategy(conditionals :: Matrix{<:Real}) <: AbstractMatrix{Float64}\n\nStrategy(conditionals :: Conditionals) <: AbstractMatrix{Float64}\n\nThe conditionals parameter is a column stochastic matrix which can be provided in a raw Matrix{<:Real} format or as a Conditionals type from the QBase.jl package. By default, the constructor creates a strategy for a 'BlackBox' scenario. However, a Scenario can be passed to the Strategy constructor.\n\nStrategy(conditionals :: Matrix{<:Real}, scenario :: Scenario)\n\nErrors:\n\nA DomainError is thrown if:\n\nThe provided Scenario does not match the expected dimension of the conditionals matrix.\nThe conditionals matrix is not a valid stochastic matrix, e.g. non-negative and normalized.\n\n\n\n\n\n","category":"type"},{"location":"BellScenario/strategies/#BellScenario.strategy_dims","page":"Strategies","title":"BellScenario.strategy_dims","text":"strategy_dims( scenario :: Scenario ) :: Tuple{Int64, Int64}\n\nReturns the dimensions of the Conditionals matrix describing a Strategy for the Scenario at hand. Each Scenario, can place unique constraints on the matrix dimensions, therfore, separate methods are called for each concrete Scenario.\n\n\n\n\n\n","category":"function"},{"location":"BellScenario/strategies/#BellScenario.random_strategy","page":"Strategies","title":"BellScenario.random_strategy","text":"random_strategy(\n    num_inputs :: Int64,\n    num_outputs :: Int64;\n) :: Strategy\n\nConstructs a randomized Strategy matrix. Zeros are inserted into the strategy to ensure that it does not closely resemble a uniform distribution.\n\n\n\n\n\n","category":"function"},{"location":"BellScenario/strategies/#Deterministic-Strategies","page":"Strategies","title":"Deterministic Strategies","text":"","category":"section"},{"location":"BellScenario/strategies/","page":"Strategies","title":"Strategies","text":"DeterministicStrategy\nis_deterministic\ndeterministic_strategies","category":"page"},{"location":"BellScenario/strategies/#BellScenario.DeterministicStrategy","page":"Strategies","title":"BellScenario.DeterministicStrategy","text":"DeterministicStrategy(conditionals :: Matrix{Int64}) <: AbstractStrategy{Int64}\n\nA strategy matrix describing the behavior of a deterministic black-box. A strategy deterministic if its elements satisfy P(yx)in01 in addition to the non-negativity and normalization constraints. By default, the constructor creates a strategy for a 'BlackBox' scenario, however, a Scenario can be passed to the DeterministicStrategy constructor.\n\nDeterministicStrategy(conditionals :: Matrix{Int}, scenario :: Scenario)\n\nThe product of two deterministic strategies is a DeterministicStrategy.\n\n*(S1::DeterministicStrategy, S2::DeterministicStrategy) :: DeterministicStrategy\n\nWhen multiplied a new Scenario can be specified.\n\n*(\n    S1::DeterministicStrategy,\n    S2::DeterministicStrategy,\n    scenario::Scenario\n) :: Deterministic Strategy\n\nErrors:\n\nA DomainError is thrown if:\n\nThe provided Scenario does not match the dimension of the conditionals matrix.\nThe elements of conditionals are not 0 or 1.\nThe strategy elements are not non-negative and normalized.\n\n\n\n\n\n","category":"type"},{"location":"BellScenario/strategies/#BellScenario.is_deterministic","page":"Strategies","title":"BellScenario.is_deterministic","text":"is_deterministic( strategy :: AbstractMatrix  ) :: Bool\n\nReturns true if all elements of strategy are either 0 or 1 and the matrix is a valid conditional probability distribution.\n\n\n\n\n\n","category":"function"},{"location":"BellScenario/strategies/#BellScenario.deterministic_strategies","page":"Strategies","title":"BellScenario.deterministic_strategies","text":"deterministic_strategies(scenario :: BlackBox) :: Vector{Matrix{Int64}}\n\ndeterministic_strategies(num_out :: Int64, num_in :: Int64) :: Vector{Matrix{Int64}}\n\nEnumerates the set of deterministic strategies for the specified BlackBox. For performance, enumerated deterministic strategies are left as matrices and not constructed into DeterministicStrategy types.\n\n\n\n\n\n","category":"function"},{"location":"BellScenario/strategies/#Quantum-Strategies","page":"Strategies","title":"Quantum Strategies","text":"","category":"section"},{"location":"BellScenario/strategies/","page":"Strategies","title":"Strategies","text":"quantum_strategy","category":"page"},{"location":"BellScenario/strategies/#BellScenario.quantum_strategy","page":"Strategies","title":"BellScenario.quantum_strategy","text":"Constructs a strategy matrix given quantum states and measurements. The supported scenarios include:\n\nBlackBox scenarios\n\nquantum_strategy(\n    Π :: POVM,\n    ρ_states :: Vector{<:State}\n) :: Strategy\n\nLocalSignaling scenarios\n\nquantum_strategy(\n    Π :: POVM,\n    ρ_states :: Vector{<:State},\n    scenario :: LocalSignaling\n) :: Strategy\n\nA DomainError is thrown if the provided states and measurements are not compatible with the specified scenario.\n\n\n\n\n\n","category":"function"},{"location":"BellScenario/strategies/#Behaviors","page":"Strategies","title":"Behaviors","text":"","category":"section"},{"location":"BellScenario/strategies/","page":"Strategies","title":"Strategies","text":"The conditional probabilities of a Bell scenario can be represented by data structures other than a Strategy matrix. Most notably, the conditional probabilities can be organized into a vector referred to as a behavior in the literature. A behavior is a column-major vectorization of a strategy matrix e.g. S[:]. The dimension of the behavior vector (or strategy matrix) can be reduced to an equivalent subspace by using the normalization and non-signaling constraints to removed redundant parameters of the conditional probability distribution.","category":"page"},{"location":"BellScenario/strategies/","page":"Strategies","title":"Strategies","text":"Subspaces used within BellScenario.jl include:","category":"page"},{"location":"BellScenario/strategies/","page":"Strategies","title":"Strategies","text":"\"generalized\" - All conditional probabilities P(yx) for the Bell scenario are present.\n\"normalized\" - The normalization constraint on each column is used to remove the last row of the strategy matrix.\n\"non-signaling\" - The non-signaling constraints are applied to reduce the \"normalized\" subspace further.","category":"page"},{"location":"BellScenario/strategies/#Conversion-Methods","page":"Strategies","title":"Conversion Methods","text":"","category":"section"},{"location":"BellScenario/strategies/","page":"Strategies","title":"Strategies","text":"Strategy matrices and behavior vectors are isomorphic representations. Therefore, a behavior can be converted into a strategy and vice versa.","category":"page"},{"location":"BellScenario/strategies/","page":"Strategies","title":"Strategies","text":"Currently, behaviors are loosely represented by Vector{Int64} and Vector{Float64} types and a rep argument is used to specify the subspace. This may change in future updates of BellScenario.jl.","category":"page"},{"location":"BellScenario/strategies/","page":"Strategies","title":"Strategies","text":"convert(::Type{DeterministicStrategy}, ::Vector{Int64}, ::BlackBox; ::String)\nconvert(::Type{<:AbstractStrategy}, ::Vector{Float64}, ::BipartiteNonSignaling; ::String)\nconvert(::Type{Vector{Int64}}, ::DeterministicStrategy; ::String)","category":"page"},{"location":"BellScenario/strategies/#Base.convert-Tuple{Type{DeterministicStrategy},Array{Int64,1},BlackBox}","page":"Strategies","title":"Base.convert","text":"Vertex (Vector{Int64}) -> DeterministicStrategy\n\nconvert(\n    ::Type{DeterministicStrategy},\n    vertex  :: Vector{Int64},\n    scenario :: Scenario;\n    rep = \"normalized\" :: String\n)\n\n\n\n\n\n","category":"method"},{"location":"BellScenario/strategies/#Base.convert-Tuple{Type{#s5} where #s5<:AbstractStrategy,Array{Float64,1},BipartiteNonSignaling}","page":"Strategies","title":"Base.convert","text":"convert(\n    S :: Type{<:AbstractStrategy}, vertex::Vector{<:Real}, scenario::BipartiteNonSignaling;\n    rep=\"non-signaling\" :: String\n)\n\nTransforms a behavior vector or vertex in to either a Strategy or DeterministicStrategy. If converting into a DeterministicStrategy, the vertex must contain Int64 values. Valid representations are \"non-signaling\", \"normalized\", and \"generalized\".\n\n\n\n\n\n","category":"method"},{"location":"BellScenario/strategies/#Base.convert-Tuple{Type{Array{Int64,1}},DeterministicStrategy}","page":"Strategies","title":"Base.convert","text":"DeterministicStrategy -> Vertex (Vector{Int64})\n\nconvert(\n    ::Type{Vector{Int64}},\n    strategy :: DeterministicStrategy;\n    rep = \"normalized\" :: String\n)\n\n\n\n\n\n","category":"method"},{"location":"BellScenario/scenarios/","page":"Scenarios","title":"Scenarios","text":"CurrentModule = BellScenario","category":"page"},{"location":"BellScenario/scenarios/#BellScenario.jl-Scenarios","page":"Scenarios","title":"BellScenario.jl - Scenarios","text":"","category":"section"},{"location":"BellScenario/scenarios/","page":"Scenarios","title":"Scenarios","text":"Scenario\nBlackBox\nLocalSignaling\nBipartiteNonSignaling\nBipartiteSignaling","category":"page"},{"location":"BellScenario/scenarios/#BellScenario.Scenario","page":"Scenarios","title":"BellScenario.Scenario","text":"A Scenario is an abstract type parent to all Bell scenarios. Each child of this abstract type describes a distinct black-box system configuration.\n\n\n\n\n\n","category":"type"},{"location":"BellScenario/scenarios/#BellScenario.BlackBox","page":"Scenarios","title":"BellScenario.BlackBox","text":"BlackBox(num_out :: Int64, num_in :: Int64) <: Scenario\n\nA Bell scenario consisting of a single black-box device with num_in inputs and num_out outputs.\n\n(Image: Black-Box Device)\n\nThe black-box device computes the output y from the input x by performing a stochastic map S(yx).\n\nErrors\n\nA DomainError is thrown if parameters num_out or num_in is less than 1.\n\n\n\n\n\n","category":"type"},{"location":"BellScenario/scenarios/#BellScenario.LocalSignaling","page":"Scenarios","title":"BellScenario.LocalSignaling","text":"LocalSignaling(\n    X :: Int64,\n    Y :: Int64,\n    d :: Int64,\n) <: Scenario\n\nA bipartite signaling scenario where information is passed from a transmitter black-box to a receiver black-box using no more than d dits of communication.\n\n(Image: Local Signaling Scenario)\n\nThe transmitter device has X inputs and the receiver device has Y outputs and shared randomness is held between the two devices. When quantum communication is used instead of classical communication no Bell violations occur.\n\nErrors\n\nA DomainError is thrown if X, Y, or d is less than 1.\n\n\n\n\n\n","category":"type"},{"location":"BellScenario/scenarios/#BellScenario.BipartiteNonSignaling","page":"Scenarios","title":"BellScenario.BipartiteNonSignaling","text":"BipartiteNonSignaling(\n    A :: Int64,\n    B :: Int64,\n    X :: Int64,\n    Y :: Int64\n) <: Scenario\n\nA bipartite non-signaling scenario where each device receives an input and produces an output. Let Alice be the device with A outputs and X inputs while Bob is the device with B outputs and Y inputs.\n\n(Image: Bipartite Non-Signaling Scenario)\n\nShared randomness is held between Alice and Bob. When Alice and Bob share quantum entanglement, Bell violations are known to occur.\n\nErrors\n\nA DomainError is thrown if A, B, X, or Y is less than 1.\n\n\n\n\n\n","category":"type"},{"location":"BellScenario/scenarios/#BellScenario.BipartiteSignaling","page":"Scenarios","title":"BellScenario.BipartiteSignaling","text":"BipartiteSignaling(\n    A :: Tuple{Int64, Int64},\n    B :: Tuple{Int64, Int64};\n    dits :: Int64 = 1,\n    bidirectional :: Bool = false\n) <: Scenario\n\nA bipartite signaling scenario where each device can send a message to the other.\n\n(Image: Bipartite Signaling Scenario)\n\n\n\n\n\n","category":"type"},{"location":"LocalPolytope/generators/","page":"Generators","title":"Generators","text":"CurrentModule = LocalPolytope","category":"page"},{"location":"LocalPolytope/generators/#Generating-Vertices-and-Facets","page":"Generators","title":"Generating Vertices and Facets","text":"","category":"section"},{"location":"LocalPolytope/generators/","page":"Generators","title":"Generators","text":"generator_vertex\ngenerator_facet","category":"page"},{"location":"LocalPolytope/generators/#BellScenario.LocalPolytope.generator_vertex","page":"Generators","title":"BellScenario.LocalPolytope.generator_vertex","text":"generator_vertex(\n    D :: DeterministicStrategy,\n    scenario :: LocalSignaling\n) :: DeterministicStrategy\n\nFinds the generating vertex for the provided DeterministicStrategy. The generating vertex is the lexicographic normal form of D.\n\n\n\n\n\n","category":"function"},{"location":"LocalPolytope/generators/#BellScenario.LocalPolytope.generator_facet","page":"Generators","title":"BellScenario.LocalPolytope.generator_facet","text":"generator_facet( BG :: BellGame, scenario :: LocalSignaling ) :: BellGame\n\nFinds the generating facet for the provided BellGame. The generator is provided in lexicographic normal form. The generating facet is found recursively by an algorithm which sorts by lexicographic scores.\n\n\n\n\n\n","category":"function"},{"location":"LocalPolytope/vertices/","page":"Vertices","title":"Vertices","text":"CurrentModule = LocalPolytope","category":"page"},{"location":"LocalPolytope/vertices/#Vertices","page":"Vertices","title":"Vertices","text":"","category":"section"},{"location":"LocalPolytope/vertices/","page":"Vertices","title":"Vertices","text":"Vertices are extreme points of the local polytope. They correspond to deterministic strategies.","category":"page"},{"location":"LocalPolytope/vertices/#Vertex-Enumeration","page":"Vertices","title":"Vertex Enumeration","text":"","category":"section"},{"location":"LocalPolytope/vertices/","page":"Vertices","title":"Vertices","text":"Enumerate the local polytope vertices for the specified Bell Scenario.","category":"page"},{"location":"LocalPolytope/vertices/","page":"Vertices","title":"Vertices","text":"vertices","category":"page"},{"location":"LocalPolytope/vertices/#BellScenario.LocalPolytope.vertices","page":"Vertices","title":"BellScenario.LocalPolytope.vertices","text":"vertices( scenario :: BlackBox;\n    rep = \"normalized\" :: String\n) :: Vector{Vector{Int64}}\n\nGenerates the Local Polytope vertices for a BlackBox scenario. Valid represenations are:\n\n*rep == \"normalized\" or rep == \"generalized\".\n\n\n\n\n\nvertices( scenario :: LocalSignaling;\n    rep = \"normalized\" :: String\n    rank_d_only = false :: Bool\n) ::  Vector{Vector{Int64}}\n\nGenerates the deterministic strategies for the local polytope of LocalSignaling scenarios.  The rank_d_only keyword arg specifies  whether to  exclude vertices which use fewer dits  of communication and thus have a  matrix rank less than d.\n\nwarning: Warning\nThe vertices computed in this method are vectorized directly from a strategy matrix by column-majorization. These vertices are distinct from those produced by older LocalPolytope.vertices() methods which are row-majorized.\n\n\n\n\n\nvertices( scenario :: BipartiteNonSignaling,\n    rep=\"non-signaling\" :: String\n) :: Vector{Vector{Int64}}\n\nEnumerates the LocalPolytope vertices for the BipartiteNonSignaling scenario. Valid representations for the vertices include:\n\n\"non-signaling\", \"normalized\", \"generalized\"\n\nA DomainError is thrown if a valid representation is not specified.\n\n\n\n\n\n","category":"function"},{"location":"LocalPolytope/vertices/#Vertex-Counting","page":"Vertices","title":"Vertex Counting","text":"","category":"section"},{"location":"LocalPolytope/vertices/","page":"Vertices","title":"Vertices","text":"Count the number of local polytope vertices for the specified Bell Scenario.","category":"page"},{"location":"LocalPolytope/vertices/","page":"Vertices","title":"Vertices","text":"num_vertices","category":"page"},{"location":"LocalPolytope/vertices/#BellScenario.LocalPolytope.num_vertices","page":"Vertices","title":"BellScenario.LocalPolytope.num_vertices","text":"num_vertices( scenario :: BlackBox ) :: Int64\n\nFor n outputs and m inputs the number of vertices mathcalV are counted:\n\nmathbfV = n^m\n\n\n\n\n\nnum_vertices( scenario :: LocalSignaling;\n    rank_d_only = false :: Bool\n) :: Int64\n\nIf rank_d_only = true, then only strategies using  d-dits are counted. For X inputs and Y outputs the number of vertices mathcalV are counted:\n\nmathbfV = sum_c=1^d leftX atop c rightbinomYcc\n\n\n\n\n\nnum_vertices( scenario :: BipartiteNonSignaling ) :: Int64\n\nFor two non-signaling black-boxes with X and Y inputs and A and B outputs respectively, the number of vertices mathcalV are counted:\n\nmathbfV = A^X B^Y\n\n\n\n\n\n","category":"function"},{"location":"LocalPolytope/vertices/#Vertex-Dimension","page":"Vertices","title":"Vertex Dimension","text":"","category":"section"},{"location":"LocalPolytope/vertices/","page":"Vertices","title":"Vertices","text":"Get the dimension of specified vertex representation.","category":"page"},{"location":"LocalPolytope/vertices/","page":"Vertices","title":"Vertices","text":"vertex_dims","category":"page"},{"location":"LocalPolytope/vertices/#BellScenario.LocalPolytope.vertex_dims","page":"Vertices","title":"BellScenario.LocalPolytope.vertex_dims","text":"For the given Scenario, returns the length of the vertex in the representation specified by rep. A DomainError is thrown if the rep is invalid.\n\nvertex_dims(scenario :: Union{BlackBox,LocalSignaling}, rep :: String) :: Int64\n\nValid values of rep are \"normalized\" and \"generalized\".\n\n\n\n\n\nvertex_dims( scenario:: BipartiteNonSignaling, rep :: String ) :: Int64\n\nValid values for rep include:\n\n\"non-signaling\"\n\"normalized\"\n\"generalized\"\n\n\n\n\n\n","category":"function"},{"location":"LocalPolytope/facets/","page":"Facets","title":"Facets","text":"CurrentModule = LocalPolytope","category":"page"},{"location":"LocalPolytope/facets/#Facet-Enumeration","page":"Facets","title":"Facet Enumeration","text":"","category":"section"},{"location":"LocalPolytope/facets/","page":"Facets","title":"Facets","text":"facets","category":"page"},{"location":"LocalPolytope/facets/#BellScenario.LocalPolytope.facets","page":"Facets","title":"BellScenario.LocalPolytope.facets","text":"facets(\n    vertices :: Vector{Vector{Int64}};\n    dir = \"./\" :: String,\n    cleanup=true :: Bool\n) :: Dict{String, Vector{Vector{Int64}}}\n\nComputes the facet inequalities and equalities which bound the convex polyhedron defined by the set of vertices. If the optimal representation is used for the vertices, then no equalitities will be present. For example, if the \"generalized\" vertex representation is used the normalization constraints will be included in the resulting equalities. The output of this method is structured:\n\nDict(\n    \"facets\" => inequalities, # :: Vector{Vector{Int64}}\n    \"equalitites\" => equalities, # :: Vector{Vector{Int64}}\n)\n\nFacet inequalities and equalities are represented as single vector f where f[1:(end-1)] contains the coefficients of the linear inquality and f[end] is the bound. Facet inequalities and equalities act upon a vertex v where inequalities are arranged such that there is an implicit f[1:(end-1)]' * v ≤ f[end] and equalities are arranged such that f[1:(end-1)]' * v == f[end]\n\nnote: Supporting Software\nThe vertex -> facet transformation is performed using the traf method of XPORTA.jl. Please refer to the source code for more details.\n\nwarning: Performance Limitations\nVertex -> facet transformations are notoriously difficult computational problems. The performance limits of this method will be met far before the limits the vertex enumeration methods.\n\n\n\n\n\n","category":"function"},{"location":"development_manual/#Development-Manual","page":"Development Manual","title":"Development Manual","text":"","category":"section"},{"location":"development_manual/#Develop-BellComm.jl-Pkg","page":"Development Manual","title":"Develop BellComm.jl Pkg","text":"","category":"section"},{"location":"development_manual/","page":"Development Manual","title":"Development Manual","text":"This project is packaged using Pkg.jl. For code changes to be reflected in the packaged software, the package must be set to development mode. This is done by running the command:","category":"page"},{"location":"development_manual/","page":"Development Manual","title":"Development Manual","text":"julia -e 'using Pkg; Pkg.develop(\"BellComm\")'","category":"page"},{"location":"development_manual/#Run-Tests","page":"Development Manual","title":"Run Tests","text":"","category":"section"},{"location":"development_manual/","page":"Development Manual","title":"Development Manual","text":"Run the BellComm.jl package tests (continuous integration):","category":"page"},{"location":"development_manual/","page":"Development Manual","title":"Development Manual","text":"julia -e 'using Pkg;  Pkg.test(\"BellComm\")'","category":"page"},{"location":"development_manual/","page":"Development Manual","title":"Development Manual","text":"Download test dependencies into local environment:","category":"page"},{"location":"development_manual/","page":"Development Manual","title":"Development Manual","text":"julia --project=test/ -e 'using Pkg; Pkg.instantiate()'","category":"page"},{"location":"development_manual/","page":"Development Manual","title":"Development Manual","text":"Run tests from a dev environment:","category":"page"},{"location":"development_manual/","page":"Development Manual","title":"Development Manual","text":"julia test/path/to/test_file.jl","category":"page"},{"location":"development_manual/#Build-Docs","page":"Development Manual","title":"Build Docs","text":"","category":"section"},{"location":"development_manual/","page":"Development Manual","title":"Development Manual","text":"Deploy docs server on local machine:","category":"page"},{"location":"development_manual/","page":"Development Manual","title":"Development Manual","text":"cd docs/build/; python3 -m http.server --bind localhost","category":"page"},{"location":"development_manual/","page":"Development Manual","title":"Development Manual","text":"Build docs from BellComm.jl source (continuous integration):","category":"page"},{"location":"development_manual/","page":"Development Manual","title":"Development Manual","text":"Download docs dependencies into local environment:\n julia --project=docs/ -e 'using Pkg; Pkg.develop(PackageSpec(path=pwd())); Pkg.instantiate()'","category":"page"},{"location":"development_manual/","page":"Development Manual","title":"Development Manual","text":"Build docs:\n julia --project=docs/ docs/make.jl","category":"page"},{"location":"development_manual/","page":"Development Manual","title":"Development Manual","text":"Build docs from a dev environment:","category":"page"},{"location":"development_manual/","page":"Development Manual","title":"Development Manual","text":"julia -e 'using Pkg; Pkg.add(\"Documenter\")'","category":"page"},{"location":"development_manual/","page":"Development Manual","title":"Development Manual","text":"julia docs/make.jl","category":"page"},{"location":"Nonlocality/optimize_measurements/","page":"Optimize Measurements","title":"Optimize Measurements","text":"CurrentModule = Nonlocality","category":"page"},{"location":"Nonlocality/optimize_measurements/#Optimize-Measurements","page":"Optimize Measurements","title":"Optimize Measurements","text":"","category":"section"},{"location":"Nonlocality/optimize_measurements/","page":"Optimize Measurements","title":"Optimize Measurements","text":"optimize_measurement","category":"page"},{"location":"Nonlocality/optimize_measurements/#BellScenario.Nonlocality.optimize_measurement","page":"Optimize Measurements","title":"BellScenario.Nonlocality.optimize_measurement","text":"LocalSignaling scenario:\n\noptimize_measurement(\n    scenario :: LocalSignaling,\n    game :: BellGame,\n    ρ_states :: Vector{<:State}\n)\n\nFinds the measurement that optimizes the score of the BellGame against the set of quantum states ρ_states. The optimization is performed with the following semi-definite program:\n\nbeginaligned\nmax_Pi_y sum_xy G_xy textTrPi_y rho_x \nst quad sum_y Pi_y = mathbbI quad Pi_y geq 0\nendaligned\n\n\n\n\n\nBipartiteNonSignaling scenario:\n\noptimize_measurement(\n    game :: BellGame,\n    scenario :: BipartiteNonSignaling,\n    ρ_AB :: State;\n    A_POVMs :: Vector{<:POVM},\n) :: Dict\n\nFind Bob's measurement which optimizes a BellGame's score for the shared quantum state ρ_AB and POVM measurement applied by Alice. The following semi-definite program optimizes the Bob's POVM:\n\nbeginaligned\n    max_Pi_b^y sum_abxy G_abxytextTr(Pi_a^x otimes Pi_b^y)rho_AB \n    st quad sum_b Pi_b^y = mathbbIquad Pi_b^y geq 0 quad forall y\nendaligned\n\noptimize_measurement(\n    game :: BellGame,\n    scenario :: BipartiteNonSignaling,\n    ρ_AB :: State;\n    B_POVMs :: Vector{<:POVM},\n) :: Dict\n\nFind Alice's measurement which optimizes a BellGame's score for the shared quantum state ρ_{AB} and POVM measurement applied by Bob. The following semi-definite program optimizes the Alice's POVM:\n\nbeginaligned\nmax_Pi_a^x sum_abxy G_abxytextTr(Pi_a^x otimes Pi_b^y)rho_AB \nst quad sum_a Pi_a^x = mathbbIquad Pi_a^x geq 0 quad forall x\nendaligned\n\n\n\n\n\n","category":"function"},{"location":"Nonlocality/overview/#Nonlocality.jl-Overview","page":"Overview","title":"Nonlocality.jl Overview","text":"","category":"section"},{"location":"Nonlocality/overview/","page":"Overview","title":"Overview","text":"Nonlocality","category":"page"},{"location":"Nonlocality/overview/#BellScenario.Nonlocality","page":"Overview","title":"BellScenario.Nonlocality","text":"Find the optimal parameters for quantum Bell violations.\n\nThe Nonlocality.jl module provides tools to optimize quantum non-locality in Bell scenarios.\n\nModule Exports:\n\noptimize_measurement: Finds the quantum measurement which violates   a specified Bell inequality maximally.\n\n\n\n\n\n","category":"module"},{"location":"LocalPolytope/adjacency_decomposition/","page":"Adjacency Decomposition","title":"Adjacency Decomposition","text":"CurrentModule = LocalPolytope","category":"page"},{"location":"LocalPolytope/adjacency_decomposition/#Adjacency-Decomposition","page":"Adjacency Decomposition","title":"Adjacency Decomposition","text":"","category":"section"},{"location":"LocalPolytope/adjacency_decomposition/","page":"Adjacency Decomposition","title":"Adjacency Decomposition","text":"adjacency_decomposition\nadjacent_facets\nrotate_facet","category":"page"},{"location":"LocalPolytope/adjacency_decomposition/#BellScenario.LocalPolytope.adjacency_decomposition","page":"Adjacency Decomposition","title":"BellScenario.LocalPolytope.adjacency_decomposition","text":"adjacenecy_decomposition(\n    vertices :: Vector{Vector{Int64}},\n    BG_seed :: BellGame,\n    scenario :: LocalSignaling;\n    kwargs...\n) :: Dict\n\nGiven a polytpe represented by vertices, returns the complete set of canonical facets for prepare and measure scenario scenario. The adjacencydecomposition algorithm requires a seeded vertex which is supplied with the `BGseed` argument. Facets are returned in the lexicographic normal form.\n\nReturned Dictionary Format\n\nReturns a dictionary where the keys are canonical BellGames and the value is a dictionary with keys\n\n\"considered\" => true, if the facet was considered in the algorithm.\n\"skipped\" => true, if the facet was skipped (not considered).\n\"num_vertices\" => number of vertices.\n\"norm_facet\" => facet vector representative (normalized rep) of canonical game\n\nKeyword  Arguments: kwargs...\n\nskip_games = [] ::  Vector{BellGame} - List of games to skip.\nmax_vertices = 100 :: Int64 - The maximum number of vertices to allow in target facets.\ndir = \"./\" :: String- Directory in which to createporta_tmp/and.json` files.\nlog = false :: Bool - If true, the facet dictionary is  written to .json each iteration.\nlog_filename = \"adjacency_decomposition_now.json\" :: String\n\n\n\n\n\n","category":"function"},{"location":"LocalPolytope/adjacency_decomposition/#BellScenario.LocalPolytope.adjacent_facets","page":"Adjacency Decomposition","title":"BellScenario.LocalPolytope.adjacent_facets","text":"adjacent_facets(\n    vertices :: Vector{Vector{Int64}},\n    F :: Vector{int64};\n    dir = \"./\" :: String,\n    cleanup = true ::Bool\n) :: Vector{Vector{Int64}}\n\nFor the polytope represented by vertices, returns the set of facets adjacent to F.\n\nFacet vector F and the return facet vectors are assumed to ba in the normalized subspace.\n\nThe  dir argument specifies where to where to write files and directories from XPORTA.jl. If cleanup is true, then a  porta_tmp directory is created as a subdirectory of dir.\n\nIf cleanup is false, the created  porta_tmp directory is not removed.\n\n\n\n\n\n","category":"function"},{"location":"LocalPolytope/adjacency_decomposition/#BellScenario.LocalPolytope.rotate_facet","page":"Adjacency Decomposition","title":"BellScenario.LocalPolytope.rotate_facet","text":"rotate_facet(\n    F :: Vector{Int64},\n    G :: Vector{Int64},\n    xbar :: Vector{Int64}\n) :: Vector{Int64}\n\nPerforms a rotation of facet F relative to non-included vertex xbar and returns the rotated facet vector. F is a polytope facet, G is a subfacet of F and xbar is a vertex not contained by F. By construction, the rotated facet contains xbar.\n\n\n\n\n\n","category":"function"},{"location":"user_guide/#User-Guide","page":"User Guide","title":"User Guide","text":"","category":"section"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"using Pkg; Pkg.add(\"BellScenario\")","category":"page"},{"location":"BellScenario/games/","page":"Games","title":"Games","text":"CurrentModule = BellScenario","category":"page"},{"location":"BellScenario/games/#BellScenario.jl-Games","page":"Games","title":"BellScenario.jl - Games","text":"","category":"section"},{"location":"BellScenario/games/","page":"Games","title":"Games","text":"AbstractGame\nGame\nBellGame","category":"page"},{"location":"BellScenario/games/#BellScenario.AbstractGame","page":"Games","title":"BellScenario.AbstractGame","text":"An AbstractGame is the abstract type that is parent to type representing a cost function for strategies. A Game is a linear inequality dual to Strategy matrices, it is represented by a matrix G containing scalar coefficients and a bound beta. The bound of the linear inequality is typically a maximum score attainable by Bell scenario using a certain set of resources. A Game G is played by a Strategy S to achieve a score computed as,\n\nbeta geq langle G Srangle = sum_xy G_yxS(yx)\n\nThe game is \"won\" if the strategy scores greater than beta, that is, the above inequality is violated. Since beta is the maximum score for a set of resources, the game is won only if the tested strategy used a set of resources of greater operational value than than considered when computing the bound beta.\n\nConveniently, Strategy matrices have normalized columns and non-negative elements. This means that any game inequality can be converted into a form where game matrix G has positive elements and beta designates a positive upper bound.\n\n\n\n\n\n","category":"type"},{"location":"BellScenario/games/#BellScenario.Game","page":"Games","title":"BellScenario.Game","text":"Game(game::Matrix{T}, β::Real) <: AbstractGame{T}\n\nA Game is represented by a Matrix of coefficients and a scalar bound β.\n\nType parameter T can be either Int64 or Float64.\n\n\n\n\n\n","category":"type"},{"location":"BellScenario/games/#BellScenario.BellGame","page":"Games","title":"BellScenario.BellGame","text":"BellGame(game::Matrix{Int64}, β::Int64, scenario::Scenario)\n\nA BellGame represents a Bell inequality or tight facet of the local polytope. Since the vertices of the local polytope are deterministic strategies with 0,1 elements, the linear inequalities describing facets of the local polytope have rational coefficients. Therefore, if a inequality tightly bounds the local polytope, it can be represented by a game with integer coefficients. \n\n\n\n\n\n","category":"type"},{"location":"BellScenario/games/#Conversion-Methods","page":"Games","title":"Conversion Methods","text":"","category":"section"},{"location":"BellScenario/games/","page":"Games","title":"Games","text":"A BellGame is a matrix representation of a linear inequality that bounds a LocalPolytope for some Scenario. For convenience, conversion methods are provided to transform BellGames to alternative representations of polytope facets. There are two supported types which can be converted to/from BellGames:","category":"page"},{"location":"BellScenario/games/","page":"Games","title":"Games","text":"Facet - Vector{Int64}, a column-major vectorization of the game matrix with     the bound placed in the last element of the vector.\nIEQ - A facet data structure defined in XPORTA.jl.","category":"page"},{"location":"BellScenario/games/","page":"Games","title":"Games","text":"convert(::Type{BellGame},::Vector{Int64},::BlackBox)\nconvert(::Type{BellGame},::Vector{Int64},::BipartiteNonSignaling)\nconvert(::Type{Vector{Int64}}, ::BellGame)\nconvert(::Type{Vector{Int64}},BG::BellGame,scenario::BipartiteNonSignaling)\nconvert(::Type{Vector{BellGame}},::IEQ,::BlackBox)\nconvert(::Type{IEQ}, bell_games::Vector{BellGame})","category":"page"},{"location":"BellScenario/games/#Base.convert-Tuple{Type{BellGame},Array{Int64,1},BlackBox}","page":"Games","title":"Base.convert","text":"Facet (Vector{Int64}) -> BellGame\n\nconvert(\n    ::Type{BellGame},\n    facet::Vector{Int64},\n    scenario::Union{BlackBox, LocalSignaling};\n    rep = \"normalized\"::String\n)\n\n\n\n\n\n","category":"method"},{"location":"BellScenario/games/#Base.convert-Tuple{Type{BellGame},Array{Int64,1},BipartiteNonSignaling}","page":"Games","title":"Base.convert","text":"Facet (Vector{Int64}) -> BellGame\n\nconvert(\n    ::Type{BellGame},\n    facet::Vector{Int64},\n    scenario::BipartiteNonSignaling;\n    rep = \"non-signaling\"::String\n)\n\nTransforms LocalPolytope facets into BellGame  types.\n\n\n\n\n\n","category":"method"},{"location":"BellScenario/games/#Base.convert-Tuple{Type{Array{Int64,1}},BellGame}","page":"Games","title":"Base.convert","text":"BellGame -> Facet (Vector{Int64})\n\nconvert(::Type{Vector{Int64}}, BG::BellGame; rep = \"normalized\" :: String)\n\n\n\n\n\n","category":"method"},{"location":"BellScenario/games/#Base.convert-Tuple{Type{Array{Int64,1}},BellGame,BipartiteNonSignaling}","page":"Games","title":"Base.convert","text":"BellGame -> Vector{Int64}\n\nconvert(::Type{Vector{Int64}},\n    BG::BellGame,\n    scenario::BipartiteNonSignaling;\n    rep = \"non-signaling\" :: String\n)\n\nTransforms a BellGame for a BipartiteNonSignaling scenario into a facet vector.\n\n\n\n\n\n","category":"method"},{"location":"BellScenario/games/#Base.convert-Tuple{Type{Array{BellGame,1}},XPORTA.IEQ,BlackBox}","page":"Games","title":"Base.convert","text":"XPORTA.IEQ to BellGame's\n\nconvert(\n    ::Type{Vector{BellGame}},\n    ieq::IEQ,\n    scenario::Union{BlackBox, LocalSignaling};\n    rep = \"normalized\" :: String\n)\n\n\n\n\n\n","category":"method"},{"location":"BellScenario/games/#Base.convert-Tuple{Type{XPORTA.IEQ},Array{BellGame,1}}","page":"Games","title":"Base.convert","text":"BellGame's to XPORTA.IEQ\n\nconvert(::Type{IEQ}, bell_games::Vector{BellGame}; rep = \"normalized\" :: String)\n\n\n\n\n\n","category":"method"},{"location":"BellScenario/games/#File-I/O","page":"Games","title":"File I/O","text":"","category":"section"},{"location":"BellScenario/games/","page":"Games","title":"Games","text":"In practice, one may need to view are large set of BellGames in a human-readable form.","category":"page"},{"location":"BellScenario/games/","page":"Games","title":"Games","text":"pretty_print_txt","category":"page"},{"location":"BellScenario/games/#BellScenario.pretty_print_txt","page":"Games","title":"BellScenario.pretty_print_txt","text":"pretty_print_txt( bell_games :: Vector{BellGame}, filename :: String )\n\nPrints a set of BellGame's to filename.txt in a human-readable form.\n\n\n\n\n\n","category":"function"},{"location":"LocalPolytope/overview/#Local-Polytope-Overview","page":"Overview","title":"Local Polytope Overview","text":"","category":"section"},{"location":"LocalPolytope/overview/","page":"Overview","title":"Overview","text":"LocalPolytope","category":"page"},{"location":"LocalPolytope/overview/#BellScenario.LocalPolytope","page":"Overview","title":"BellScenario.LocalPolytope","text":"Compute the bounds of classical Bell scenarios.\n\nThe LocalPolytope.jl module provides tools for characterizing the convex polyhedral structure of the correlations attainable using classical resources in a Bell scenario.\n\nEach distinct strategy for a given Bell scenario corresponds to a point in vector space. The complete set of attainable strategies for a particular Bell scenario is denoted mathbfP. Given the constraints of normalization and non-negativity, the extreme points of mathbfP correspond to deterministic strategies (matrices with 0,1 elements). Furthermore, when shared randomness is used in a Bell scenario, any two strategies can be mixed together in a convex combination. Hence, mathbfP is a convex polyhedron referred to as the local polytope.\n\nA convex polytope has two equivalent descriptions:\n\nV-Description: The polytope is the convex hull of a set of extreme points  known as vertices mathbfV,  quadmathbfP = textconv(mathbfV).\nH-Description: The polytope is the intersection of a set of linear half-spaces  known as facets mathbfF,  quadmathbfP = capmathbfF.\n\nThese two descriptions are equivalent,\n\nmathbfP = textconv(mathbfV) = capmathbfF\n\nand there exists a transformation between the set of vertices and facets mathbfV leftrightarrow mathbfF.\n\nFor a given Bell scenario, the V-Description is typically easier to compute, however, the H-Description describes the bounds of the local polytope as as linear inequalities known as Bell inequalities. Bell inequalities are important because they provide a simple test to verify that a strategy is not contained by the local polyotpe. That is, if a Bell inequality is violated, the classical resources considered for the local polytope are not sufficient to reproduce the strategy. Hence, a Bell violation witnesses the use of resources with greater operational value. Bell violations are often used to characterize the advantages of quantum resources, however, it is important to note that a Bell violation can simply mean that more classical resources were used than anticipated.\n\nModule Exports:\n\nvertices - Compute the set of extreme-points for the Local Polytope.\nfacets - Compute the linear inequalities which bound the Local Polytope.\ngenerator_vertex - Provide a canonical form for a vertex.\ngenerator_facet - Provide a canonical form for a facet.\nadjacency_decomposition - Efficiently compute the generating facets for the Local   Polytope using the adjacency decomposition technique.\n\n\n\n\n\n","category":"module"},{"location":"#BellScenario.jl","page":"Home","title":"BellScenario.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Compute Bell inequalities and their quantum violations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This software is a general tool for analyzing quantum non-locality in Bell scenarios.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Alpha Version\nBreaking changes will be made in future commits.","category":"page"},{"location":"#Featured-Modules","page":"Home","title":"Featured Modules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BellScenario: Types and constructors for describing Bell scenarios.\nLocalPolytope: Computes the bounds classical Bell Scenarios.\nNonlocality: Optimizes quantum states and measurements for non-locality.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Bell scenario describes a system of inter-connected black-box devices. A black-box is a simple device which takes an input and produces an output, however, no assumptions are made about the physical process inside the black-box. Black-boxes and Bell scenarios are completely characterized by their input-output statistics. The statistics of a Bell scenario depends on the underlying physics used by the black-box devices.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In most familiar cases, a black-box uses classical physics. Some examples of classical black-boxes include cars, slot machines, and software. Classical physics is deterministic, although, an observer of a classical black-box may not have access to the parameters required to predict the output. These parameters are called local hidden variables where local means that events occurring in one location of space-time do not affect another location. Essentially, classical black-boxes are deterministic while their local hidden variables create the perception of probabilistic behavior. Hence, any probabilistic mixture of deterministic black-box behaviors can, in principle, be realized for a given Bell scenario. The bounds of a classical Bell scenario's statistics are regarded as Bell inequalities and the set of all possible behaviors forms a convex polyhedron known as the local polytope.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Bell scenarios are of interest to fundamental physics because not all physical systems adhere to the constraint of locality. For example, quantum Bell scenarios are able to realize statistics unattainable by their corresponding classical systems. This non-local behavior manifests as a strong correlation between distant points in space-time. The non-local correlations of quantum systems result in operational advantages in communications, information security, and data processing applications.","category":"page"},{"location":"","page":"Home","title":"Home","text":"While the success of many future technologies depends on realizing quantum non-locality, this task is very difficult, even in a theoretical sense. To witness non-locality, the local bounds must first be derived. Then, the parameters of the equivalent quantum system must be tuned to violate the derived Bell inequalities. Each of these problems are challenging analytically and numerically. The BellScenario.jl package provides the basic toolkit for finding non-locality in quantum systems.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"user_guide.md\", \"BellScenario/overview.md\", \"LocalPolytope/overview.md\", \"Nonlocality/overview.md\", \"development_manual.md\",]\nDepth = 1","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Development of BellScenario.jl was made possible by the advisory of Dr. Eric Chitambar and general support from the Physics Department at the University of Illinois Urbana-Champaign. Funding was provided by NSF Award 1914440.","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To reference this work, see CITATION.bib.","category":"page"},{"location":"#Licensing","page":"Home","title":"Licensing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BellScenario.jl is released under the MIT License.","category":"page"}]
}
