var documenterSearchIndex = {"docs":
[{"location":"BellScenario/overview/#Overview-1","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"bell_comm_scenarios/#Bell-Communication-Scenarios-1","page":"Communication Scenarios","title":"Bell Communication Scenarios","text":"","category":"section"},{"location":"BellScenario/strategies/#","page":"Strategies","title":"Strategies","text":"CurrentModule = BellScenario","category":"page"},{"location":"BellScenario/strategies/#Black-box-Strategies-1","page":"Strategies","title":"Black-box Strategies","text":"","category":"section"},{"location":"BellScenario/strategies/#","page":"Strategies","title":"Strategies","text":"Strategy\nstrategy_dims","category":"page"},{"location":"BellScenario/strategies/#BellScenario.Strategy","page":"Strategies","title":"BellScenario.Strategy","text":"A strategy matrix describing the statistical behavior of a black-box.\n\nStrategy(conditionals :: Matrix{<:Real}) <: AbstractMatrix{Float64}\n\nBy default, the constructor creates a strategy for a 'BlackBox' scenario. However, a Scenario can also be passed to the Strategy constructor.\n\nStrategy(conditionals :: Matrix{<:Real}, scenario :: Scenario)\n\nA DomainError is thrown if the provided Scenario does not match the dimension of the conditionals matrix.\n\n\n\n\n\n","category":"type"},{"location":"BellScenario/strategies/#BellScenario.strategy_dims","page":"Strategies","title":"BellScenario.strategy_dims","text":"strategy_dims( scenario :: Scenario ) :: Tuple{Int, Int}\n\nReturns the dimensions of the Conditionals matrix describing a Strategy for the Scenario at hand. Each Scenario, can place unique constraints on the matrix dimensions, therfore, separate methods are called for each concrete Scenario.\n\n\n\n\n\n","category":"function"},{"location":"BellScenario/scenarios/#","page":"Scenarios","title":"Scenarios","text":"CurrentModule = BellScenario","category":"page"},{"location":"BellScenario/scenarios/#Black-box-Scenarios-1","page":"Scenarios","title":"Black-box Scenarios","text":"","category":"section"},{"location":"BellScenario/scenarios/#","page":"Scenarios","title":"Scenarios","text":"Scenario\nBlackBox\nBipartite\nPrepareAndMeasure","category":"page"},{"location":"BellScenario/scenarios/#BellScenario.Scenario","page":"Scenarios","title":"BellScenario.Scenario","text":"An abstract type to represent general black-box scenarios.\n\n\n\n\n\n","category":"type"},{"location":"BellScenario/scenarios/#BellScenario.BlackBox","page":"Scenarios","title":"BellScenario.BlackBox","text":"BlackBox(num_in :: Int64, num_out :: Int64) <: Scenario\n\nA black-box scenario considering a single device. A black-box is an uncharacterized device with a finite number of classical inputs and outputs.\n\nA DomainError is throw if parameters num_in or num_out is less than 1.\n\n\n\n\n\n","category":"type"},{"location":"BellScenario/scenarios/#BellScenario.Bipartite","page":"Scenarios","title":"BellScenario.Bipartite","text":"Bipartite(\n    A :: Tuple{Int64, Int64},\n    B :: Tuple{Int64, Int64};\n    dits :: Int = 1,\n    bidirectional :: Bool = false\n) <: Scenario\n\nA black-box scenario with two devices and possible communication between the devices. The keyword parameter dits describes the number of dits used for communication and bidirectional describes whether communication is simultaneous between each party.\n\n\n\n\n\n","category":"type"},{"location":"BellScenario/scenarios/#BellScenario.PrepareAndMeasure","page":"Scenarios","title":"BellScenario.PrepareAndMeasure","text":"PrepareAndMeasure(\n    X :: Int,\n    B :: Int,\n    d :: Int,\n)\n\nA black-box scenario with X inputs, B outputs, and d-dits of communication from the input device to the output device.\n\n\n\n\n\n","category":"type"},{"location":"LocalPolytope/generators/#","page":"Generators","title":"Generators","text":"CurrentModule = LocalPolytope","category":"page"},{"location":"LocalPolytope/generators/#Generating-Vertices-and-Facets-1","page":"Generators","title":"Generating Vertices and Facets","text":"","category":"section"},{"location":"LocalPolytope/generators/#","page":"Generators","title":"Generators","text":"generator_facet","category":"page"},{"location":"LocalPolytope/generators/#BellScenario.LocalPolytope.generator_facet","page":"Generators","title":"BellScenario.LocalPolytope.generator_facet","text":"generator_facet( BG :: BellGame, PM :: PrepareAndMeasure ) :: BellGame\n\nFinds the generating facet for the provided BellGame. The generator is provided in lexicographic normal form. The generating facet is found recursively by an algorithm which sorts by lexicographic scores.\n\n\n\n\n\n","category":"function"},{"location":"quantum_nonlocality/#Quantum-Nonlocality-1","page":"Quantum Nonlocality","title":"Quantum Nonlocality","text":"","category":"section"},{"location":"development_manual/#Development-Manual-1","page":"Development Manual","title":"Development Manual","text":"","category":"section"},{"location":"development_manual/#Develop-BellComm.jl-Pkg-1","page":"Development Manual","title":"Develop BellComm.jl Pkg","text":"","category":"section"},{"location":"development_manual/#","page":"Development Manual","title":"Development Manual","text":"This project is packaged using Pkg.jl. For code changes to be reflected in the packaged software, the package must be set to development mode. This is done by running the command:","category":"page"},{"location":"development_manual/#","page":"Development Manual","title":"Development Manual","text":"julia -e 'using Pkg; Pkg.develop(\"BellComm\")'","category":"page"},{"location":"development_manual/#Run-Tests-1","page":"Development Manual","title":"Run Tests","text":"","category":"section"},{"location":"development_manual/#","page":"Development Manual","title":"Development Manual","text":"Run the BellComm.jl package tests (continuous integration):","category":"page"},{"location":"development_manual/#","page":"Development Manual","title":"Development Manual","text":"julia -e 'using Pkg;  Pkg.test(\"BellComm\")'","category":"page"},{"location":"development_manual/#","page":"Development Manual","title":"Development Manual","text":"Download test dependencies into local environment:","category":"page"},{"location":"development_manual/#","page":"Development Manual","title":"Development Manual","text":"julia --project=test/ -e 'using Pkg; Pkg.instantiate()'","category":"page"},{"location":"development_manual/#","page":"Development Manual","title":"Development Manual","text":"Run tests from a dev environment:","category":"page"},{"location":"development_manual/#","page":"Development Manual","title":"Development Manual","text":"julia test/path/to/test_file.jl","category":"page"},{"location":"development_manual/#Build-Docs-1","page":"Development Manual","title":"Build Docs","text":"","category":"section"},{"location":"development_manual/#","page":"Development Manual","title":"Development Manual","text":"Deploy docs server on local machine:","category":"page"},{"location":"development_manual/#","page":"Development Manual","title":"Development Manual","text":"cd docs/build/; python3 -m http.server --bind localhost","category":"page"},{"location":"development_manual/#","page":"Development Manual","title":"Development Manual","text":"Build docs from BellComm.jl source (continuous integration):","category":"page"},{"location":"development_manual/#","page":"Development Manual","title":"Development Manual","text":"Download docs dependencies into local environment:\n julia --project=docs/ -e 'using Pkg; Pkg.develop(PackageSpec(path=pwd())); Pkg.instantiate()'","category":"page"},{"location":"development_manual/#","page":"Development Manual","title":"Development Manual","text":"Build docs:\n julia --project=docs/ docs/make.jl","category":"page"},{"location":"development_manual/#","page":"Development Manual","title":"Development Manual","text":"Build docs from a dev environment:","category":"page"},{"location":"development_manual/#","page":"Development Manual","title":"Development Manual","text":"julia -e 'using Pkg; Pkg.add(\"Documenter\")'","category":"page"},{"location":"development_manual/#","page":"Development Manual","title":"Development Manual","text":"julia docs/make.jl","category":"page"},{"location":"user_guide/#User-Guide-1","page":"User Guide","title":"User Guide","text":"","category":"section"},{"location":"BellScenario/adjacency_decomposition/#","page":"Adjacency Decomposition","title":"Adjacency Decomposition","text":"CurrentModule = LocalPolytope","category":"page"},{"location":"BellScenario/adjacency_decomposition/#Adjacency-Decomposition-1","page":"Adjacency Decomposition","title":"Adjacency Decomposition","text":"","category":"section"},{"location":"BellScenario/adjacency_decomposition/#","page":"Adjacency Decomposition","title":"Adjacency Decomposition","text":"adjacency_decomposition\nadjacent_facets\nrotate_facet","category":"page"},{"location":"BellScenario/adjacency_decomposition/#BellScenario.LocalPolytope.adjacency_decomposition","page":"Adjacency Decomposition","title":"BellScenario.LocalPolytope.adjacency_decomposition","text":"adjacenecy_decomposition(vertices, BG_seed::BellGame, PM::PrepareAndMeasure; kwargs )\n\nGiven a polytpe represented by vertices, returns the complete set of canonical facets for prepare and measure scenario PM. The adjacencydecomposition algorithm requires a seeded vertex which is supplied with the `BGseed` argument. Facets are returned in the lexicographic normal form.\n\nKeyword  arguments kwargs\n\nskip_games ::  Vector{BellGame} - Optional list of games to skip.\nmax_vertices :: Int64 - Defaults to 100, the maximum number of vertices to allow in target facets.\n\n\n\n\n\n","category":"function"},{"location":"BellScenario/adjacency_decomposition/#BellScenario.LocalPolytope.adjacent_facets","page":"Adjacency Decomposition","title":"BellScenario.LocalPolytope.adjacent_facets","text":"adjacent_facets( vertices, F::HalfSpace, PM::PrepareAndMeasure )\n\nFor the polytope represented by vertices, returns the canonical set of facets adjacent to F for the specified prepare and measure scenario PM.\n\nF is assumed to ba a valid facet in the normalized subspace.\n\n\n\n\n\n","category":"function"},{"location":"BellScenario/adjacency_decomposition/#BellScenario.LocalPolytope.rotate_facet","page":"Adjacency Decomposition","title":"BellScenario.LocalPolytope.rotate_facet","text":"rotate_facet(F::HalfSpace, G::HalfSpace, xbar::Vector{Int})\n\nPerforms a rotation of facet F relative to non-included vertex xbar. Returns the rotated HalfSpace. F is a polytope facet, G is a facet of F and xbar is a vertex not contained on the boundary of F.\n\n\n\n\n\n","category":"function"},{"location":"BellScenario/games/#","page":"Games","title":"Games","text":"CurrentModule = BellScenario","category":"page"},{"location":"BellScenario/games/#Black-Box-Games-1","page":"Games","title":"Black-Box Games","text":"","category":"section"},{"location":"BellScenario/games/#","page":"Games","title":"Games","text":"AbstractGame\nGame\nBellGame","category":"page"},{"location":"BellScenario/games/#BellScenario.AbstractGame","page":"Games","title":"BellScenario.AbstractGame","text":"Games represent a linear inequality.\n\n\n\n\n\n","category":"type"},{"location":"BellScenario/games/#BellScenario.Game","page":"Games","title":"BellScenario.Game","text":"Game(game::Matrix{T}, β::Real) <: AbstractMatrix{T}\n\nA Game is played by a Matrix and β is the bounding or winning score of the game. AGame` is matrix representation of a linear inequality. Each element is a linear scale factor for an element of a strategy matrix.\n\nType parameter T is typically an Int64 or Float64.\n\n\n\n\n\n","category":"type"},{"location":"BellScenario/games/#BellScenario.BellGame","page":"Games","title":"BellScenario.BellGame","text":"BellGame(game::Matrix{Int64}, β::Int64, scenario::Scenario)\n\nA tight Bell inequality for the correlation polytope for scenario.\n\n\n\n\n\n","category":"type"},{"location":"local_bounds/#Local-Bounds-1","page":"Local Bounds","title":"Local Bounds","text":"","category":"section"},{"location":"#BellComm.jl-1","page":"Home","title":"BellComm.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Compute Bell inequalities and their quantum violations.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"BellComm.jl performs two tasks:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Computes the local polytope for classical bipartite Bell Scenarios enhanced with classical communication.\nOptimizes quantum states and measurements to find maximal quantum violations of the local bounds.","category":"page"}]
}
